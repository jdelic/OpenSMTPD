Revert "GCM is available in all LibreSSL versions" (d74dbd3)
GCM is not available on OpenSSL versions < 1.0.2. Restores old OpenSSL
compatibility. (This patch is safe to remove on OpenSSL 1.1.1a.)
Index: opensmtpd/configure.ac
===================================================================
--- opensmtpd.orig/configure.ac
+++ opensmtpd/configure.ac
@@ -1155,6 +1155,25 @@ fi
 #l2816
 
 
+##chl
+EXPERIMENTAL_GCM_CRYPTO=no
+AC_MSG_CHECKING([if programs using LibreSSL EVP_aes_256_gcm() will link])
+AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM([[ #include <openssl/evp.h> ]],
+	[[ EVP_aes_256_gcm(); ]])],
+	[
+		AC_MSG_RESULT([yes])
+		AC_DEFINE([HAVE_GCM_CRYPTO], [1],
+			[Define if you want to use GCM crypto support])
+		EXPERIMENTAL_GCM_CRYPTO=yes
+	],
+	[
+		AC_MSG_RESULT([no])
+	]
+)
+AM_CONDITIONAL([HAVE_GCM_CRYPTO], [test $EXPERIMENTAL_GCM_CRYPTO = yes])
+##chl
+
 ##gilles
 
 SMTPD_USER=_smtpd
Index: opensmtpd/mk/smtpctl/Makefile.am
===================================================================
--- opensmtpd.orig/mk/smtpctl/Makefile.am
+++ opensmtpd/mk/smtpctl/Makefile.am
@@ -32,7 +32,9 @@ smtpctl_SOURCES+=	$(smtpd_srcdir)/mailad
 smtpctl_SOURCES+=	$(smtpd_srcdir)/makemap.c
 endif
 
+if HAVE_GCM_CRYPTO
 smtpctl_SOURCES+=	$(smtpd_srcdir)/crypto.c
+endif
 
 smtpctl_CFLAGS=		-DNO_IO -DCONFIG_MINIMUM
 smtpctl_CFLAGS+=	-DPATH_GZCAT=\"$(ZCAT)\" \
Index: opensmtpd/mk/smtpd/Makefile.am
===================================================================
--- opensmtpd.orig/mk/smtpd/Makefile.am
+++ opensmtpd/mk/smtpd/Makefile.am
@@ -71,7 +71,9 @@ smtpd_SOURCES+=		$(smtpd_srcdir)/util.c
 smtpd_SOURCES+=		$(smtpd_srcdir)/waitq.c
 
 # backends
+if HAVE_GCM_CRYPTO
 smtpd_SOURCES+=		$(smtpd_srcdir)/crypto.c
+endif
 smtpd_SOURCES+=		$(smtpd_srcdir)/compress_gzip.c
 if HAVE_DB_API
 smtpd_SOURCES+=		$(smtpd_srcdir)/table_db.c
Index: opensmtpd/smtpd/queue.c
===================================================================
--- opensmtpd.orig/smtpd/queue.c
+++ opensmtpd/smtpd/queue.c
@@ -646,11 +646,13 @@ queue(void)
 	if (env->sc_queue_flags & QUEUE_COMPRESSION)
 		log_info("queue: queue compression enabled");
 
+#ifdef HAVE_GCM_CRYPTO
 	if (env->sc_queue_key) {
 		if (!crypto_setup(env->sc_queue_key, strlen(env->sc_queue_key)))
 			fatalx("crypto_setup: invalid key for queue encryption");
 		log_info("queue: queue encryption enabled");
 	}
+#endif
 
 	if (setgroups(1, &pw->pw_gid) ||
 	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
Index: opensmtpd/smtpd/queue_backend.c
===================================================================
--- opensmtpd.orig/smtpd/queue_backend.c
+++ opensmtpd/smtpd/queue_backend.c
@@ -253,6 +253,7 @@ queue_message_commit(uint32_t msgid)
 		}
 	}
 
+#ifdef HAVE_GCM_CRYPTO
 	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
 		bsnprintf(tmppath, sizeof tmppath, "%s.enc", msgpath);
 		ifp = fopen(msgpath, "r");
@@ -274,6 +275,7 @@ queue_message_commit(uint32_t msgid)
 			return (0);
 		}
 	}
+#endif
 
 	r = handler_message_commit(msgid, msgpath);
 	profile_leave();
@@ -312,6 +314,7 @@ queue_message_fd_r(uint32_t msgid)
 	if (fdin == -1)
 		return (-1);
 
+#ifdef HAVE_GCM_CRYPTO
 	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
 		if ((fdout = mktmpfile()) == -1)
 			goto err;
@@ -333,6 +336,7 @@ queue_message_fd_r(uint32_t msgid)
 		ofp = NULL;
 		lseek(fdin, SEEK_SET, 0);
 	}
+#endif
 
 	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
 		if ((fdout = mktmpfile()) == -1)
@@ -389,8 +393,10 @@ queue_envelope_dump_buffer(struct envelo
 	size_t	evplen;
 	size_t	complen;
 	char	compbuf[sizeof(struct envelope)];
+#ifdef HAVE_GCM_CRYPTO
 	size_t	enclen;
 	char	encbuf[sizeof(struct envelope)];
+#endif
 
 	evp = evpbuf;
 	evplen = envelope_dump_buffer(ep, evpbuf, evpbufsize);
@@ -405,6 +411,7 @@ queue_envelope_dump_buffer(struct envelo
 		evplen = complen;
 	}
 
+#ifdef HAVE_GCM_CRYPTO
 	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
 		enclen = crypto_encrypt_buffer(evp, evplen, encbuf, sizeof encbuf);
 		if (enclen == 0)
@@ -412,6 +419,7 @@ queue_envelope_dump_buffer(struct envelo
 		evp = encbuf;
 		evplen = enclen;
 	}
+#endif
 
 	memmove(evpbuf, evp, evplen);
 
@@ -425,12 +433,15 @@ queue_envelope_load_buffer(struct envelo
 	size_t		 evplen;
 	char		 compbuf[sizeof(struct envelope)];
 	size_t		 complen;
+#ifdef HAVE_GCM_CRYPTO
 	char		 encbuf[sizeof(struct envelope)];
 	size_t		 enclen;
+#endif
 
 	evp = evpbuf;
 	evplen = evpbufsize;
 
+#ifdef HAVE_GCM_CRYPTO
 	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
 		enclen = crypto_decrypt_buffer(evp, evplen, encbuf, sizeof encbuf);
 		if (enclen == 0)
@@ -438,6 +449,7 @@ queue_envelope_load_buffer(struct envelo
 		evp = encbuf;
 		evplen = enclen;
 	}
+#endif
 
 	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
 		complen = uncompress_chunk(evp, evplen, compbuf, sizeof compbuf);
Index: opensmtpd/smtpd/smtpctl.c
===================================================================
--- opensmtpd.orig/smtpd/smtpctl.c
+++ opensmtpd/smtpd/smtpctl.c
@@ -1314,7 +1314,9 @@ static void
 display(const char *s)
 {
 	FILE   *fp;
+#ifdef HAVE_GCM_CRYPTO
 	char   *key;
+#endif
 	int	gzipped;
 	char   *gzcat_argv0 = strrchr(PATH_GZCAT, '/') + 1;
 
@@ -1322,6 +1324,7 @@ display(const char *s)
 		err(1, "fopen");
 
 	if (is_encrypted_fp(fp)) {
+#ifdef HAVE_GCM_CRYPTO
 		int	i;
 		FILE   *ofp = NULL;
 
@@ -1344,6 +1347,10 @@ display(const char *s)
 		fclose(fp);
 		fp = ofp;
 		fseek(fp, 0, SEEK_SET);
+#else
+	       	printf("GCM crypto not supported!\n");
+       		exit(1);
+#endif
 	}
 	gzipped = is_gzip_fp(fp);
 
Index: opensmtpd/smtpd/smtpd.c
===================================================================
--- opensmtpd.orig/smtpd/smtpd.c
+++ opensmtpd/smtpd/smtpd.c
@@ -673,12 +673,14 @@ main(int argc, char *argv[])
 		errx(1, "config file exceeds PATH_MAX");
 
 	if (env->sc_opts & SMTPD_OPT_NOACTION) {
+#ifdef HAVE_GCM_CRYPTO
 		if (env->sc_queue_key &&
 		    crypto_setup(env->sc_queue_key,
 		    strlen(env->sc_queue_key)) == 0) {
 			fatalx("crypto_setup:"
 			    "invalid key for queue encryption");
 		}
+#endif
 		load_pki_tree();
 		load_pki_keys();
 		fprintf(stderr, "configuration OK\n");
